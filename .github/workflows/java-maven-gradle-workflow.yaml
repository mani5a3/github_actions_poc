name: java-maven-gradle-workflow

on:
  workflow_dispatch:
  workflow_call:
    inputs:
      runner:
        description: "Runner to use"
        required: true
        type: string
      java_version:
        description: "Java version to use"
        required: true
        type: string
      build_tool:
        description: "select the build tool whether it is maven or gradle"
        required: true
        type: string
      maven_goals:
        description: "Maven goals to run (e.g. clean install)"
        required: false
        default: "clean install"
        type: string
      Sonar_ScannerHome:
        description: "Sonar scanner home path"
        type: string
      Sonar_ProjectKey:
        description: "Sonar project key"
        type: string
      Sonar_ProjectName:
        description: "Sonar project name"
        type: string
      Sonar_JavaSource:
        description: "java version"
        type: string
      Sonar_sources:
        description: "Sonar sources source code path"
        type: string
      Sonar_tests:
        description: "Sonar project key"
        type: string
      Sonar_Javabinaries:
        description: "Sonar java binaries"
        type: string
      Sonar_Jacaco_ReportPaths:
        description: "Sonar jacoco report paths"
        type: string
      Sonar_Junit_ReportPaths:
        description: "Sonar junit report paths"
        type: string

    secrets:
      Jfrog_Username:
        required: true
      Jfrog_Password:
        required: true
      Sonar_Token:
        required: true
      Sonar_HostUrl:
        required: true

jobs:
  build_and_deploy:
    runs-on: [self-hosted, "${{ inputs.runner }}"]
    steps:
    - name: checkout repository
      uses: actions/checkout@v6

    - name: Setup Java
      uses: actions/setup-java@v5
      with:
        java-version: ${{ inputs.java_version }}
        distribution: 'temurin'
        cache: ${{ inputs.build_tool }}


    - name: compile the maven code
      if: ${{ inputs.build_tool == 'maven' }}
      run: mvn clean verify -Drevision=${{ github.run_number }}

    - name: compile the gradle code
      if: ${{ inputs.build_tool == 'gradle' }}
      run: ./gradlew build -x test


    - name: sonar static code analysis
      shell: powershell
      run: |
        & "${{ inputs.Sonar_ScannerHome }}" `
          "-Dsonar.projectKey=${{ inputs.Sonar_ProjectKey }}" `
          "-Dsonar.projectName=${{ inputs.Sonar_ProjectName }}" `
          "-Dsonar.projectVersion=${{ github.run_number }}" `
          "-Dsonar.java.source=${{ inputs.Sonar_JavaSource }}" `
          "-Dsonar.host.url=${{ secrets.Sonar_HostUrl }}" `
          "-Dsonar.login=${{ secrets.Sonar_Token }}" `
          "-Dsonar.sources=${{ inputs.Sonar_sources }}" `
          "-Dsonar.tests=${{ inputs.Sonar_tests }}" `
          "-Dsonar.java.binaries=${{ inputs.Sonar_Javabinaries }}" `
          "-Dsonar.coverage.jacoco.xmlReportPaths=${{ inputs.Sonar_Jacaco_ReportPaths }}" `
          "-Dsonar.junit.reportPaths=${{ inputs.Sonar_Junit_ReportPaths }}"

    - name: SonarQube Quality Gate
      shell: powershell
      env:
        SONAR_TOKEN: ${{ secrets.Sonar_Token }}
        SONAR_HOST_URL: ${{ secrets.Sonar_HostUrl }}
      run: |
        Write-Host "Starting SonarQube Quality Gate check"

        # Path to Sonar report file
        $reportPath = ".scannerwork/report-task.txt"
        if (-not (Test-Path $reportPath)) {
            Write-Error "Report file not found: $reportPath"
            exit 1
        }

        Write-Host "Reading Sonar report"
        $reportLines = Get-Content $reportPath

        # Extract compute engine task URL
        $ceLine = $reportLines | Where-Object { $_ -match "^ceTaskUrl=" }
        if (-not $ceLine) {
            Write-Error "ceTaskUrl entry not found in report"
            exit 1
        }
        $ceUrl = $ceLine -replace "^ceTaskUrl=", ""
        Write-Host "Compute engine URL: $ceUrl"

        # Prepare authentication header for Sonar API
        $pair = "$($env:SONAR_TOKEN):"
        $bytes = [System.Text.Encoding]::ASCII.GetBytes($pair)
        $base64 = [System.Convert]::ToBase64String($bytes)
        $headers = @{ Authorization = "Basic $base64" }

        Write-Host "Polling Sonar compute engine"
        $finalStatus = ""
        do {
            Start-Sleep -Seconds 5
            try {
                $taskResponse = Invoke-RestMethod -Uri $ceUrl -Headers $headers -ErrorAction Stop
                $currentStatus = $taskResponse.task.status
                Write-Host "Current status: $currentStatus"
                $finalStatus = $currentStatus
            } catch {
                Write-Host "Error calling compute engine API, retrying"
                $finalStatus = ""
            }
        } while ($finalStatus -ne "SUCCESS" -and $finalStatus -ne "FAILED")

        if ($finalStatus -ne "SUCCESS") {
            Write-Error "Sonar compute engine did not complete successfully: $finalStatus"
            exit 1
        }

        Write-Host "Compute engine analysis completed"

        # Extract analysis identifier
        $analysisId = $taskResponse.task.analysisId
        Write-Host "Analysis identifier: $analysisId"

        # Build quality gate API URL
        $qgUrl = "$env:SONAR_HOST_URL/api/qualitygates/project_status?analysisId=$analysisId"
        Write-Host "Quality gate API URL: $qgUrl"

        # Call quality gate API
        try {
            $qgResponse = Invoke-RestMethod -Uri $qgUrl -Headers $headers -ErrorAction Stop
        } catch {
            Write-Error "Failed to retrieve quality gate status"
            exit 1
        }

        $qgStatus = $qgResponse.projectStatus.status
        Write-Host "Quality gate status: $qgStatus"

        if ($qgStatus -ne "OK") {
            Write-Error ("Quality gate failed with status: " + $qgStatus)
            exit 1
        }

        Write-Host "Quality gate passed"



#-----------------linux runner -----------------------------------   
# - name: SonarQube Quality Gate check
#   id: sonarqube-quality-gate-check
#   uses: sonarsource/sonarqube-quality-gate-action@master
#   with:
#     pollingTimeoutSec: 180
#   env:
#     SONAR_TOKEN: ${{ secrets.Sonar_Token }}
#     SONAR_HOST_URL: ${{ secrets.Sonar_HostUrl }}

# # Optionally you can use the output from the Quality Gate in another step.
# # The possible outputs of the `quality-gate-status` variable are `PASSED`, `WARN` or `FAILED`.
# - name: "show SonarQube Quality Gate Status value"
#   run: echo "The Quality Gate status is ${{ steps.sonarqube-quality-gate-check.outputs.quality-gate-status }}"